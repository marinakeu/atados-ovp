from django.core.cache import cache

from ovp.apps.catalogue.models import Catalogue

from ovp.apps.projects.models import Project
from ovp.apps.organizations.models import Organization

from ovp.apps.search.querysets import (
    get_project_queryset,
    get_organization_queryset
)
from ovp.apps.search import filters

from ovp.apps.projects.serializers.project import ProjectSearchSerializer
from ovp.apps.organizations.serializers import OrganizationSearchSerializer

from collections import OrderedDict

from haystack.query import SearchQuerySet, SQ


def get_project_keys(address, closed, channel, skip_address_filter=False):
    queryset = SearchQuerySet().models(Project)
    queryset = filters.by_published(queryset, 'true')
    queryset = filters.by_closed(queryset, closed)
    queryset = filters.by_address(
        queryset,
        address,
        project=False) if not skip_address_filter else queryset
    queryset = filters.by_channel_content_flow(queryset, channel)

    return [q.pk for q in queryset]


def get_organization_keys(address, channel, skip_address_filter=False):
    queryset = SearchQuerySet().models(Organization)
    queryset = filters.by_published(queryset, 'true')
    queryset = filters.by_address(
        queryset,
        address,
        project=False) if not skip_address_filter else queryset
    queryset = filters.by_channel_content_flow(queryset, channel)

    return [q.pk for q in queryset]


def get_catalogue(channel, slug, request):
    """
    Generates and caches a dictionary containing information about
    a given catalogue. This does not query the database to fetch
    the projects for a given catalog, it should be passed to fetch_catalogue
    for that.
    """
    key = "catalogue-{}-{}-{}".format(
        channel,
        slug,
        hash(frozenset(request.GET.items()))
    )
    result = cache.get(key)

    if not result:
        try:
            catalogue = Catalogue.objects.prefetch_related(
                "sections",
                "sections__filters"
            ).get(slug=slug, channel__slug=channel)
        except Catalogue.DoesNotExist:
            result = None
        else:
            result = {
                "name": catalogue.name,
                "slug": catalogue.slug,
                "fetched": False,
                "sections": [],
            }

            for section in catalogue.sections.all().order_by('-order'):
                section_dict = {
                    "name": section.name,
                    "slug": section.slug,
                    "amount": section.amount,
                    "skip_address_filter": section.skip_address_filter,
                    "filters": [],
                    "type": section.type,
                }

                for section_filter in section.filters.all():
                    section_dict["filters"].append(
                        section_filter.filter.get_filter_kwargs()
                    )

                result["sections"].append(section_dict)

    return result


def fetch_user_relevance_catalogue(
        catalogue,
        queryset,
        request,
        context=None,
        serializer=None):
    section_dict = {
        "name": "Recomendado para vocÃª",
        "slug": "recomendado-para-voce",
        "amount": 4,
    }

    user_filter = filters.UserSkillsCausesFilter()
    queryset = user_filter.annotate_queryset(queryset, request.user)
    queryset = queryset.order_by("-relevance")[:4]

    if serializer:
        result = ProjectSearchSerializer(
            queryset,
            many=True,
            context=context
        ).data
    else:
        result = queryset

    section_dict["projects"] = result
    catalogue["sections"].insert(0, section_dict)

    return catalogue


def fetch_catalogue(catalogue_dict, serializer=False, request=None,
                    context=None, channel='default', slug=None):
    """
    Fetchs a catalogue dict generated by get_catalogue()

    It removes the key "filters" and add the key "projects" to
    every section in the catalogue.

    The projects key added is a QuerySet. It can be serialized
    by passing a serializer argument.
    """
    # Base queryset
    if catalogue_dict["fetched"] and not request.user.is_authenticated:
        return catalogue_dict

    params = request.GET
    address = params.get('address', None)
    closed = params.get('closed', 'false')

    project_keys = get_project_keys(
        address, closed, channel, skip_address_filter=False)
    organization_keys = get_organization_keys(
        address, channel, skip_address_filter=False)
    project_base_queryset = get_project_queryset(
        request=request).filter(
        pk__in=project_keys).order_by("-created_date")

    if catalogue_dict["fetched"] and request.user.is_authenticated:
        catalogue_dict = fetch_user_relevance_catalogue(
            catalogue_dict,
            queryset=project_base_queryset,
            request=request,
            context=context,
            serializer=serializer)

        return catalogue_dict

    for i, section in enumerate(catalogue_dict["sections"]):
        if catalogue_dict["sections"][i]["type"] == "organizations":
            organization_keys = get_organization_keys(
                address, channel, skip_address_filter=section["skip_address_filter"])
            qs = get_organization_queryset(request=request).filter(
                pk__in=organization_keys).order_by("-created_date")
        else:
            project_keys = get_project_keys(
                address, closed, channel, skip_address_filter=section["skip_address_filter"])
            qs = get_project_queryset(request=request).filter(
                pk__in=project_keys).order_by("-created_date")
            qs = filters.filter_out(qs, "FILTER_OUT_PROJECTS", channel)

        # Filter queryset
        for kwargs in section["filters"]:
            qs = qs.filter(**kwargs)
        del catalogue_dict["sections"][i]["filters"]

        # Limit queryset
        qs = qs[:section["amount"]]

        # Serialize queryset
        if serializer:
            if catalogue_dict["sections"][i]["type"] == "organizations":
                result = OrganizationSearchSerializer(
                    qs,
                    many=True,
                    context=context
                ).data
            else:
                result = ProjectSearchSerializer(
                    qs,
                    many=True,
                    context=context
                ).data
        else:
            result = qs

        section_item = catalogue_dict["sections"][i]
        section_item[catalogue_dict["sections"][i]["type"]] = result

    catalogue_dict["fetched"] = True

    key = "catalogue-{}-{}-{}".format(
        channel,
        slug,
        hash(frozenset(request.GET.items()))
    )
    cache_ttl = 360
    cache.set(key, catalogue_dict, cache_ttl)

    if request.user.is_authenticated:
        catalogue_dict = fetch_user_relevance_catalogue(
            catalogue_dict,
            queryset=project_base_queryset,
            request=request,
            context=context,
            serializer=serializer
        )

    return catalogue_dict
